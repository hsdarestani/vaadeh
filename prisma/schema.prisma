// Prisma schema aligned to core platform MVP
// Generated models capture authentication, menu, ordering, and payments.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String    @id @default(cuid())
  createdAt      DateTime  @default(now())
  lastLoginAt    DateTime?
  mobile         String    @unique
  telegramUserId String?   @unique
  isBlocked      Boolean   @default(false)
  isActive       Boolean   @default(false)
  role           UserRole  @default(CUSTOMER)

  addresses      Address[]
  orders         Order[]
  payments       Payment[]
  notificationLogs NotificationLog[]
  eventLogs      EventLog[]
}

model Address {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  title       String
  lat         Float
  lng         Float
  fullAddress String
  isDefault   Boolean  @default(false)

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String
}

model Vendor {
  id              String     @id @default(cuid())
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  name            String
  lat             Float
  lng             Float
  serviceRadiusKm Float
  telegramChatId  String?
  contactPhone    String?
  isActive        Boolean    @default(true)
  maxDailyOrders  Int?

  menuItems MenuItem[]
  orders    Order[]
  notificationLogs NotificationLog[]
  eventLogs EventLog[]
}

model MenuItem {
  id        String      @id @default(cuid())
  createdAt DateTime    @default(now())
  updatedAt DateTime    @updatedAt
  name      String
  isActive  Boolean     @default(true)

  vendor   Vendor       @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  vendorId String

  variants MenuVariant[]
}

model MenuVariant {
  id         String   @id @default(cuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  code       String
  price      Decimal  @db.Decimal(10, 2)
  isAvailable Boolean  @default(true)

  menuItem   MenuItem @relation(fields: [menuItemId], references: [id], onDelete: Cascade)
  menuItemId String

  orderItems OrderItem[]
}

model Order {
  id              String              @id @default(cuid())
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  userId          String
  vendorId        String
  addressSnapshot Json
  deliveryType    DeliveryType
  deliverySettlementType DeliverySettlementType?
  deliveryFeeEstimated Decimal? @db.Decimal(10, 2)
  deliveryFeeFinal     Decimal? @db.Decimal(10, 2)
  deliveryFee     Decimal             @db.Decimal(10, 2) @default(0)
  totalPrice      Decimal             @db.Decimal(10, 2)
  adminNote       String?
  customerNote    String?
  scheduledAt     DateTime?
  locationLat     Float
  locationLng     Float
  status          OrderStatus         @default(DRAFT)
  paymentStatus   PaymentStatus       @default(PENDING)

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  vendor  Vendor  @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  items   OrderItem[]
  history OrderStatusHistory[]
  payment Payment?
  notifications NotificationLog[]
  events EventLog[]
}

model OrderItem {
  id            String      @id @default(cuid())
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  qty           Int
  unitPrice     Decimal     @db.Decimal(10, 2)

  order         Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId       String

  menuVariant   MenuVariant @relation(fields: [menuVariantId], references: [id], onDelete: Cascade)
  menuVariantId String
}

model OrderStatusHistory {
  id        String      @id @default(cuid())
  order     Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId   String
  status    OrderStatus
  changedAt DateTime    @default(now())
  note      String?
}

model Payment {
  id         String        @id @default(cuid())
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  orderId    String        @unique
  provider   PaymentProvider
  trackId    String
  amount     Decimal       @db.Decimal(10, 2)
  status     PaymentStatus @default(PENDING)
  verifiedAt DateTime?

  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  user  User? @relation(fields: [userId], references: [id])
  userId String?

  attempts PaymentAttempt[]
}

model PaymentAttempt {
  id        String         @id @default(cuid())
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
  payment   Payment        @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentId String
  requestId String?
  trackId   String
  amount    Decimal        @db.Decimal(10, 2)
  status    PaymentStatus
  rawResponse Json
  type      PaymentAttemptType
}

enum OrderStatus {
  DRAFT
  PLACED
  VENDOR_ACCEPTED
  VENDOR_REJECTED
  PREPARING
  READY
  COURIER_ASSIGNED
  OUT_FOR_DELIVERY
  DELIVERED
  CANCELLED
}

enum DeliveryType {
  IN_ZONE_INTERNAL
  SNAPP_COURIER_OUT_OF_ZONE
}

enum PaymentStatus {
  NONE
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum DeliverySettlementType {
  POSTPAID
}

enum PaymentProvider {
  ZIBAL
}

enum PaymentAttemptType {
  REQUEST
  CALLBACK
  VERIFY
}

enum NotificationChannel {
  TELEGRAM
  SMS
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
}

enum EventActorType {
  USER
  VENDOR
  ADMIN
  SYSTEM
}

model ProductEvent {
  id        String         @id @default(cuid())
  createdAt DateTime       @default(now())
  eventName String
  actorType EventActorType
  actorId   String?
  orderId   String?
  metadata  Json
}

enum UserRole {
  ADMIN
  CUSTOMER
}

model EventLog {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  eventName     String
  actorType     EventActorType?
  actorId       String?
  correlationId String?
  metadata      Json

  order   Order?  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId String?

  user   User? @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String?

  vendor   Vendor? @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  vendorId String?
}

model NotificationLog {
  id        String               @id @default(cuid())
  createdAt DateTime             @default(now())
  channel   NotificationChannel
  recipient String
  message   String
  eventName String?
  status    NotificationStatus   @default(PENDING)
  attempts  Int                  @default(0)
  lastError String?

  order   Order? @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId String?

  user   User? @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String?

  vendor   Vendor? @relation(fields: [vendorId], references: [id], onDelete: Cascade)
  vendorId String?
}
